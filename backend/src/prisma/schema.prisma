generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [vector]
}

// Multi-Tenant Core Models
model Tenant {
  id            String   @id @default(uuid())
  name          String
  subdomain     String   @unique
  domain        String?  @unique
  status        TenantStatus @default(ACTIVE)
  settings      Json?    @db.JsonB
  subscriptionPlanId String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?

  // Relations
  users         User[]
  documents     Document[]
  folders       Folder[]
  subscriptionPlan SubscriptionPlan? @relation(fields: [subscriptionPlanId], references: [id])
  paymentRecords PaymentRecord[]
  auditLogs     AuditLog[]
  featureSliderSlides FeatureSliderSlide[]
  otpVerifications OtpVerification[]

  @@index([subdomain])
  @@index([status])
  @@map("tenants")
}

enum TenantStatus {
  ACTIVE
  SUSPENDED
  INACTIVE
}

model User {
  id            String   @id @default(uuid())
  tenantId      String
  email         String
  password      String
  firstName     String
  lastName      String
  avatar        String?
  status        UserStatus @default(ACTIVE)
  emailVerified Boolean  @default(false)
  phone         String?
  phoneVerified Boolean? @default(false)
  alternativePhone String?
  timeZone      String?
  address       String?
  lastLoginAt   DateTime?
  metadata      Json?    @db.JsonB
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?

  // Relations
  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userRoles     UserRole[]
  documents     Document[]
  folders       Folder[]
  refreshTokens RefreshToken[]
  auditLogs     AuditLog[]

  @@unique([tenantId, email])
  @@index([tenantId])
  @@index([email])
  @@map("users")
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

model Role {
  id            String   @id @default(uuid())
  name          String   @unique
  description   String?
  isSystem      Boolean  @default(false)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  userRoles     UserRole[]
  permissions   RolePermission[]

  @@map("roles")
}

model Permission {
  id            String   @id @default(uuid())
  name          String   @unique
  resource      String
  action        String
  description   String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  roles         RolePermission[]

  @@index([resource, action])
  @@map("permissions")
}

model RolePermission {
  id            String   @id @default(uuid())
  roleId        String
  permissionId  String
  
  createdAt     DateTime @default(now())

  // Relations
  role          Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission    Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
  @@map("role_permissions")
}

model UserRole {
  id            String   @id @default(uuid())
  userId        String
  roleId        String
  
  createdAt     DateTime @default(now())

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role          Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@map("user_roles")
}

model Folder {
  id            String   @id @default(uuid())
  tenantId      String
  name          String
  parentId      String?
  path          String   // Materialized path for efficient queries
  ownerId       String
  permissions   Json?    @db.JsonB // Folder-level ACL
  metadata      Json?    @db.JsonB
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?

  // Relations
  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  owner         User     @relation(fields: [ownerId], references: [id])
  parent        Folder?  @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children      Folder[] @relation("FolderHierarchy")
  documents     Document[]

  @@index([tenantId])
  @@index([parentId])
  @@index([path])
  @@index([ownerId])
  @@map("folders")
}

model Document {
  id            String   @id @default(uuid())
  tenantId      String
  folderId      String?
  ownerId       String
  name          String
  originalName  String
  mimeType      String
  size          BigInt
  storageKey    String   // S3 key or file path
  version       Int      @default(1)
  status        DocumentStatus @default(PENDING)
  checksum      String?
  tags          String[]
  metadata      Json?    @db.JsonB
  extractedText String?  @db.Text
  permissions   Json?    @db.JsonB // Document-level ACL
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?

  // Relations
  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  folder        Folder?  @relation(fields: [folderId], references: [id], onDelete: SetNull)
  owner         User     @relation(fields: [ownerId], references: [id])
  embeddings    Embedding[]
  history       DocumentHistory[]

  @@index([tenantId])
  @@index([folderId])
  @@index([ownerId])
  @@index([status])
  @@index([tags])
  @@map("documents")
}

enum DocumentStatus {
  PENDING
  PROCESSING
  READY
  FAILED
  ARCHIVED
}

model DocumentHistory {
  id            String   @id @default(uuid())
  documentId    String
  version       Int
  name          String
  size          BigInt
  storageKey    String
  checksum      String?
  changedBy     String
  changeType    ChangeType
  metadata      Json?    @db.JsonB
  
  createdAt     DateTime @default(now())

  // Relations
  document      Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@map("document_history")
}

enum ChangeType {
  CREATED
  UPDATED
  DELETED
  RESTORED
  MOVED
}

model Embedding {
  id            String   @id @default(uuid())
  documentId    String
  chunkIndex    Int
  chunkText     String   @db.Text
  vector        Unsupported("vector(1536)")?
  metadata      Json?    @db.JsonB
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  document      Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@map("embeddings")
}

model RefreshToken {
  id            String   @id @default(uuid())
  userId        String
  token         String   @unique
  expiresAt     DateTime
  isRevoked     Boolean  @default(false)
  
  createdAt     DateTime @default(now())

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("refresh_tokens")
}

model SubscriptionPlan {
  id            String   @id @default(uuid())
  name          String   @unique
  displayName   String
  description   String?
  price         Decimal  @db.Decimal(10, 2)
  currency      String   @default("USD")
  interval      BillingInterval
  features      Json     @db.JsonB
  limits        Json     @db.JsonB // storage, users, documents
  isActive      Boolean  @default(true)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  tenants       Tenant[]
  paymentRecords PaymentRecord[]

  @@map("subscription_plans")
}

enum BillingInterval {
  MONTHLY
  YEARLY
}

model PaymentRecord {
  id            String   @id @default(uuid())
  tenantId      String
  planId        String
  amount        Decimal  @db.Decimal(10, 2)
  currency      String   @default("USD")
  status        PaymentStatus @default(PENDING)
  paymentMethod String?
  transactionId String?  @unique
  metadata      Json?    @db.JsonB
  paidAt        DateTime?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  plan          SubscriptionPlan @relation(fields: [planId], references: [id])

  @@index([tenantId])
  @@index([status])
  @@map("payment_records")
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

model AuditLog {
  id            String   @id @default(uuid())
  tenantId      String
  userId        String?
  action        String
  resource      String
  resourceId    String?
  ipAddress     String?
  userAgent     String?
  metadata      Json?    @db.JsonB
  
  createdAt     DateTime @default(now())

  // Relations
  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user          User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([userId])
  @@index([resource, resourceId])
  @@index([createdAt])
  @@map("audit_logs")
}

// Feature Slider Slides Model
model FeatureSliderSlide {
  id            String   @id @default(uuid())
  tenantId      String
  title         String
  description   String
  icon          String
  imageUrl      String?
  enabled       Boolean  @default(true)
  order         Int
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([order])
  @@index([enabled])
  @@map("feature_slider_slides")
}

// OTP Verification Model
model OtpVerification {
  id            String   @id @default(uuid())
  email         String
  otp           String
  hashedOtp     String
  expiresAt     DateTime
  verificationToken String @unique
  isUsed        Boolean  @default(false)
  tenantId      String?
  userType      String   // 'tenant' or 'user'
  payload       Json     @db.JsonB // Stores registration data temporarily
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  tenant        Tenant?  @relation(fields: [tenantId], references: [id], onDelete: SetNull)

  @@index([email])
  @@index([verificationToken])
  @@index([expiresAt])
  @@index([isUsed])
  @@map("otp_verifications")
}
